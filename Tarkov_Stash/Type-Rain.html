<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Typing Rain</title>
  <style>
    :root{
      --bg0:#060b18;
      --bg1:#0b1e2e;
      --bg2:#10344b;
      --panel: rgba(10, 18, 32, .62);
      --panel2: rgba(10, 18, 32, .38);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(245,250,255,.92);
      --muted: rgba(245,250,255,.68);
      --accent: rgba(160,220,255,.92);
      --danger: rgba(255,110,110,.92);
      --good: rgba(110,255,190,.92);
      --shadow: 0 22px 90px rgba(0,0,0,.55);
      --r: 18px;
      --hudH: 74px;
      --inputH: 74px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 20% 15%, rgba(120,190,255,.16), transparent 55%),
        radial-gradient(900px 700px at 85% 20%, rgba(120,255,210,.12), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 45%, var(--bg2));
      display:grid;
      place-items:center;
      overflow:hidden;
    }

    .app{
      width:min(1120px, 94vw);
      height:min(720px, 86vh);
      border-radius: calc(var(--r) + 6px);
      position:relative;
      box-shadow: var(--shadow);
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
      overflow:hidden;
      isolation:isolate;
    }

    /* subtle moving rain sheen */
    .app::before{
      content:"";
      position:absolute; inset:-20% -20%;
      background:
        repeating-linear-gradient(110deg,
          rgba(255,255,255,.00) 0 14px,
          rgba(255,255,255,.06) 14px 16px,
          rgba(255,255,255,.00) 16px 28px);
      transform: rotate(8deg);
      animation: rainSheen 2.1s linear infinite;
      opacity:.55;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    @keyframes rainSheen{
      from{ translate: 0 -8%;}
      to{ translate: 0 8%;}
    }

    /* stars */
    .stars{
      position:absolute; inset:0;
      background:
        radial-gradient(1px 1px at 12% 18%, rgba(255,255,255,.65), transparent 60%),
        radial-gradient(1px 1px at 22% 30%, rgba(255,255,255,.55), transparent 60%),
        radial-gradient(1px 1px at 38% 12%, rgba(255,255,255,.55), transparent 60%),
        radial-gradient(1px 1px at 55% 22%, rgba(255,255,255,.45), transparent 60%),
        radial-gradient(1px 1px at 72% 15%, rgba(255,255,255,.55), transparent 60%),
        radial-gradient(1px 1px at 84% 28%, rgba(255,255,255,.40), transparent 60%),
        radial-gradient(1px 1px at 90% 12%, rgba(255,255,255,.55), transparent 60%);
      opacity:.55;
      pointer-events:none;
      z-index:0;
    }

    /* city background */
    .city{
      position:absolute; inset:0;
      background:
        radial-gradient(900px 560px at 55% 42%, rgba(180,220,255,.12), transparent 55%),
        linear-gradient(180deg, rgba(5,8,18,.05), rgba(5,8,18,.25) 70%, rgba(0,0,0,.35));
      z-index:0;
      pointer-events:none;
    }
    .city::before{
      content:"";
      position:absolute; left:-5%; right:-5%;
      bottom:0;
      height:40%;
      background:
        /* far skyline */
        linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.18)),
        repeating-linear-gradient(90deg,
          rgba(12,18,30,.00) 0 18px,
          rgba(12,18,30,.55) 18px 28px,
          rgba(12,18,30,.00) 28px 40px),
        linear-gradient(180deg, rgba(12,18,30,.30), rgba(12,18,30,.92));
      filter: blur(1px);
      opacity:.62;
      transform: translateZ(0);
      mask-image: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,.15));
    }
    .city::after{
      content:"";
      position:absolute; left:-8%; right:-8%;
      bottom:-2px;
      height:28%;
      background:
        /* near skyline */
        repeating-linear-gradient(90deg,
          rgba(0,0,0,0) 0 22px,
          rgba(5,10,20,.95) 22px 42px,
          rgba(0,0,0,0) 42px 62px),
        linear-gradient(180deg, rgba(5,10,20,.72), rgba(5,10,20,.98));
      opacity:.86;
      mask-image: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,.20));
    }

    /* HUD */
    .hud{
      position:absolute; left:14px; right:14px; top:14px;
      height: var(--hudH);
      display:flex; gap:12px; align-items:center; justify-content:space-between;
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius: var(--r);
      padding:12px 14px;
      backdrop-filter: blur(10px);
      z-index:5;
    }
    .title{
      display:flex; flex-direction:column; gap:2px;
      min-width: 210px;
    }
    .title h1{
      margin:0;
      font-size:16px;
      letter-spacing:.4px;
      font-weight:800;
    }
    .title .sub{
      font-size:12px;
      color: var(--muted);
    }

    .stats{
      display:flex; gap:12px; align-items:stretch;
      flex:1;
      justify-content:center;
      min-width: 0;
    }
    .stat{
      display:flex; flex-direction:column; gap:2px;
      padding:8px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      min-width: 120px;
    }
    .stat .k{
      font-size:11px;
      color: var(--muted);
      letter-spacing:.3px;
      text-transform: uppercase;
    }
    .stat .v{
      font-size:16px;
      font-weight:800;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .controls{
      display:flex; gap:10px; align-items:center;
      min-width: 240px;
      justify-content:flex-end;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:750;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    button:hover{ transform: translateY(-1px); background: rgba(255,255,255,.11); border-color: rgba(255,255,255,.18); }
    button:active{ transform: translateY(0px) scale(.99); }
    button.primary{
      background: rgba(160,220,255,.16);
      border-color: rgba(160,220,255,.25);
    }
    button.danger{
      background: rgba(255,110,110,.12);
      border-color: rgba(255,110,110,.20);
    }

    /* playfield */
    .field{
      position:absolute; inset:0;
      padding: 0 0 calc(var(--inputH) + 18px) 0;
      z-index:1;
    }
    .drops{
      position:absolute; inset: 0 0 calc(var(--inputH) + 18px) 0;
      z-index:2;
      overflow:hidden;
    }

    .drop{
      position:absolute;
      transform: translate3d(0,0,0);
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(160,220,255,.14);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 34px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      font-weight: 900;
      letter-spacing: .3px;
      color: rgba(245,250,255,.95);
      text-shadow: 0 2px 10px rgba(0,0,0,.35);
      user-select:none;
      will-change: transform;
      filter: saturate(1.05);
    }
    .drop::before{
      content:"";
      position:absolute;
      left: 10px;
      top: 6px;
      width: 18px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.20);
      filter: blur(.2px);
      opacity:.75;
      pointer-events:none;
    }
    .drop::after{
      content:"";
      position:absolute;
      left: 50%;
      top: 100%;
      width: 2px;
      height: 26px;
      transform: translateX(-50%);
      background: linear-gradient(180deg, rgba(160,220,255,.20), rgba(160,220,255,0));
      opacity:.55;
      pointer-events:none;
    }

    .drop .typed{
      color: rgba(110,255,190,.95);
      text-shadow: 0 0 14px rgba(110,255,190,.25);
    }
    .drop.target{
      border-color: rgba(160,220,255,.35);
      box-shadow: 0 16px 42px rgba(0,0,0,.42), 0 0 0 2px rgba(160,220,255,.08);
    }
    .drop.miss{
      animation: missPulse .24s ease-out 1;
      border-color: rgba(255,110,110,.45);
      background: rgba(255,110,110,.10);
    }
    @keyframes missPulse{
      0%{ transform: translate3d(var(--tx,0), var(--ty,0), 0) scale(1); }
      70%{ transform: translate3d(var(--tx,0), var(--ty,0), 0) scale(1.04); }
      100%{ transform: translate3d(var(--tx,0), var(--ty,0), 0) scale(.99); }
    }

    /* input bar */
    .inputBar{
      position:absolute; left:14px; right:14px; bottom:14px;
      height: var(--inputH);
      display:flex; gap:12px; align-items:center;
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius: var(--r);
      padding:12px 14px;
      backdrop-filter: blur(10px);
      z-index:6;
    }
    .prompt{
      display:flex; flex-direction:column; gap:2px;
      min-width: 180px;
    }
    .prompt .hint{
      font-size:12px; color: var(--muted);
    }
    .prompt .targetName{
      font-size:14px; font-weight:850;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="text"]{
      flex:1;
      height: 48px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 0 14px;
      font-size: 16px;
      font-weight: 800;
      outline:none;
    }
    input[type="text"]::placeholder{ color: rgba(245,250,255,.45); font-weight:700; }
    input[type="text"]:focus{
      border-color: rgba(160,220,255,.30);
      box-shadow: 0 0 0 3px rgba(160,220,255,.10);
    }

    .badge{
      display:flex; align-items:center; gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      min-width: 170px;
      justify-content:space-between;
      font-weight:800;
    }
    .badge span{
      color: var(--muted);
      font-size:12px;
      font-weight:800;
      letter-spacing:.25px;
      text-transform:uppercase;
    }

    /* overlays */
    .overlay{
      position:absolute; inset:0;
      display:grid;
      place-items:center;
      z-index:10;
      background: radial-gradient(900px 600px at 50% 35%, rgba(0,0,0,.35), rgba(0,0,0,.62));
      backdrop-filter: blur(8px);
    }
    .card{
      width:min(560px, 92vw);
      border-radius: calc(var(--r) + 6px);
      background: rgba(10, 18, 32, .70);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      padding: 18px;
    }
    .card h2{
      margin: 2px 0 6px 0;
      font-size: 20px;
      letter-spacing:.3px;
    }
    .card p{
      margin: 0 0 14px 0;
      color: var(--muted);
      line-height:1.45;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin: 12px 0 14px 0;
    }
    .pill{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      padding: 10px 12px;
      border-radius: 14px;
    }
    .pill .k{
      font-size:11px; color: var(--muted); text-transform:uppercase; letter-spacing:.25px;
    }
    .pill .v{
      margin-top:3px;
      font-size:16px; font-weight:900;
    }
    .card .row{
      display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }
    .smallNote{
      margin-top: 10px;
      font-size: 12px;
      color: rgba(245,250,255,.55);
    }

    /* responsive */
    @media (max-width: 820px){
      .stats{ display:none; }
      .title{ min-width: 160px; }
      .controls{ min-width: unset; }
      .badge{ display:none; }
      .prompt{ display:none; }
    }
  </style>
</head>
<body>
  <div class="app" id="app" aria-label="Typing Rain game">
    <div class="stars"></div>
    <div class="city"></div>

    <div class="hud" role="status" aria-live="polite">
      <div class="title">
        <h1>Typing Rain</h1>
        <div class="sub">Type falling words before they hit the street.</div>
      </div>

      <div class="stats">
        <div class="stat">
          <div class="k">Score</div>
          <div class="v" id="score">0</div>
        </div>
        <div class="stat">
          <div class="k">Level</div>
          <div class="v" id="level">1</div>
        </div>
        <div class="stat">
          <div class="k">Accuracy</div>
          <div class="v" id="accuracy">100%</div>
        </div>
        <div class="stat">
          <div class="k">Misses</div>
          <div class="v" id="misses">0 / 10</div>
        </div>
      </div>

      <div class="controls">
        <button class="primary" id="btnStart">Start</button>
        <button id="btnPause" title="Pause/Resume (Esc)">Pause</button>
        <button class="danger" id="btnReset">Reset</button>
      </div>
    </div>

    <div class="field">
      <div class="drops" id="drops" aria-hidden="true"></div>
    </div>

    <div class="inputBar">
      <div class="prompt">
        <div class="hint">Current target</div>
        <div class="targetName" id="targetLabel">None</div>
      </div>

      <input id="typing"
             type="text"
             inputmode="text"
             autocomplete="off"
             autocapitalize="off"
             spellcheck="false"
             placeholder="Type hereâ€¦ (Space/Enter clears, Esc pauses)" />

      <div class="badge" title="Combo multiplier boosts points">
        <span>Combo</span>
        <div id="combo">x1.00</div>
      </div>
    </div>

    <div class="overlay" id="overlay">
      <div class="card">
        <h2 id="overlayTitle">Typing Rain</h2>
        <p id="overlayText">
          Survive the storm: type the words before they reach the bottom. Difficulty ramps up over time.
        </p>

        <div class="grid">
          <div class="pill">
            <div class="k">How to play</div>
            <div class="v">Type the falling words</div>
          </div>
          <div class="pill">
            <div class="k">Tip</div>
            <div class="v">The lowest matching word is targeted</div>
          </div>
          <div class="pill">
            <div class="k">Controls</div>
            <div class="v">Esc pauses</div>
          </div>
          <div class="pill">
            <div class="k">Scoring</div>
            <div class="v">Longer words = more points</div>
          </div>
        </div>

        <div class="row">
          <button class="primary" id="btnPlayOverlay">Play</button>
          <button id="btnFocusInput">Focus typing</button>
        </div>
        <div class="smallNote">
          This is a single HTML file because humans love cramming everything into one place.
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const $ = (id) => document.getElementById(id);

      const app = $("app");
      const dropsEl = $("drops");
      const input = $("typing");

      const scoreEl = $("score");
      const levelEl = $("level");
      const accuracyEl = $("accuracy");
      const missesEl = $("misses");
      const comboEl = $("combo");
      const targetLabel = $("targetLabel");

      const overlay = $("overlay");
      const overlayTitle = $("overlayTitle");
      const overlayText = $("overlayText");

      const btnStart = $("btnStart");
      const btnPause = $("btnPause");
      const btnReset = $("btnReset");
      const btnPlayOverlay = $("btnPlayOverlay");
      const btnFocusInput = $("btnFocusInput");

      const WORDS = [
        "rain","city","street","cloud","storm","umbrella","window","neon","night","puddle","thunder",
        "drizzle","skyline","alley","taxi","bridge","lantern","mist","breeze","river","station","signal",
        "subway","billboard","reflection","crosswalk","headlights","backstreet","skyscraper","downpour",
        "electric","metropolis","afterglow","midnight","monsoon","forecast","commuter","coastline","cascade",
        "horizon","waterfall","lightning","atmosphere","constellation","raindrop","temperature","barometer",
        "humidity","thunderclap","precipitation","evaporation","cirrus","cumulus","stratus","overcast",
        "pressure","frontline","torrential","gutter","floodlight","streetlamp","sidewalk","construction",
        "reflectional","intersections","nightfall","moonlight","skylines","broadway","downtown","uptown",
        "raincoat","boots","splash","ripple","shimmer","glimmer","laneway","fogbank","saturation"
      ];

      const state = {
        running: false,
        paused: false,
        gameOver: false,

        score: 0,
        level: 1,

        hits: 0,
        misses: 0,
        maxMisses: 10,

        typedChars: 0,
        correctChars: 0,

        combo: 0,

        elapsed: 0,
        spawnTimer: 0,

        drops: [],
        nextId: 1,

        targetId: null,
        lastInput: "",

        fieldW: 0,
        fieldH: 0,
        bottomY: 0
      };

      // Tiny audio beeps without external files.
      let audioCtx = null;
      function beep(freq = 660, duration = 0.07, gain = 0.06, type = "sine") {
        try {
          audioCtx ??= new (window.AudioContext || window.webkitAudioContext)();
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g);
          g.connect(audioCtx.destination);
          o.start();
          o.stop(audioCtx.currentTime + duration);
        } catch {}
      }

      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

      function resize() {
        const rect = dropsEl.getBoundingClientRect();
        state.fieldW = rect.width;
        state.fieldH = rect.height;
        state.bottomY = rect.height - 8; // slightly above "street"
      }
      window.addEventListener("resize", resize, { passive:true });

      function accuracyPct() {
        if (state.typedChars <= 0) return 100;
        return Math.round((state.correctChars / state.typedChars) * 100);
      }

      function levelFromTime(t) {
        // ramps up steadily but not instantly unbearable
        return 1 + Math.floor(t / 18);
      }

      function spawnIntervalMs(level) {
        // decreases over time
        return clamp(1150 - level * 65, 420, 1150);
      }

      function fallSpeed(level) {
        // px/s
        return 70 + level * 12;
      }

      function pickWord(level) {
        // higher levels bias toward longer words
        const minLen = clamp(3 + Math.floor(level / 2), 3, 10);
        const maxLen = clamp(6 + Math.floor(level * 1.2), 8, 18);

        const pool = WORDS.filter(w => w.length >= minLen && w.length <= maxLen);
        const list = pool.length ? pool : WORDS;
        return list[(Math.random() * list.length) | 0];
      }

      function makeDrop(text) {
        const el = document.createElement("div");
        el.className = "drop";
        el.setAttribute("role", "presentation");
        el.dataset.id = String(state.nextId);

        // render with typed span if needed later
        el.textContent = text;

        dropsEl.appendChild(el);

        const padding = 24;
        const x = Math.random() * (state.fieldW - padding*2) + padding;
        const y = -30 - Math.random() * 40;

        const speed = fallSpeed(state.level) * (0.85 + Math.random() * 0.6);

        const d = {
          id: state.nextId++,
          el,
          text,
          x,
          y,
          speed
        };

        // store initial translate for miss animation vars
        el.style.setProperty("--tx", `${x}px`);
        el.style.setProperty("--ty", `${y}px`);

        state.drops.push(d);
        positionDrop(d);
      }

      function positionDrop(d) {
        d.el.style.transform = `translate3d(${d.x}px, ${d.y}px, 0) translateX(-50%)`;
        d.el.style.setProperty("--tx", `${d.x}px`);
        d.el.style.setProperty("--ty", `${d.y}px`);
      }

      function removeDrop(d) {
        if (d.el && d.el.parentNode) d.el.parentNode.removeChild(d.el);
      }

      function setTarget(id) {
        if (state.targetId === id) return;

        // remove target class from old
        if (state.targetId != null) {
          const old = state.drops.find(x => x.id === state.targetId);
          if (old) {
            old.el.classList.remove("target");
            old.el.innerHTML = escapeHtml(old.text);
          }
        }

        state.targetId = id;

        const now = state.drops.find(x => x.id === id);
        if (now) now.el.classList.add("target");

        updateTargetLabel();
        renderTypedOnTarget();
      }

      function updateTargetLabel() {
        const t = state.drops.find(x => x.id === state.targetId);
        targetLabel.textContent = t ? t.text : "None";
      }

      function escapeHtml(s){
        return s.replace(/[&<>"']/g, c => ({
          "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
        }[c]));
      }

      function renderTypedOnTarget() {
        const typed = input.value.trim();
        const t = state.drops.find(x => x.id === state.targetId);
        if (!t) return;

        if (!typed) {
          t.el.innerHTML = escapeHtml(t.text);
          return;
        }

        if (!t.text.startsWith(typed)) {
          // fallback, keep plain
          t.el.innerHTML = escapeHtml(t.text);
          return;
        }

        const a = escapeHtml(t.text.slice(0, typed.length));
        const b = escapeHtml(t.text.slice(typed.length));
        t.el.innerHTML = `<span class="typed">${a}</span>${b}`;
      }

      function findBestTarget(prefix) {
        if (!prefix) return null;

        // if current target still matches, keep it
        const cur = state.drops.find(d => d.id === state.targetId);
        if (cur && cur.text.startsWith(prefix)) return cur.id;

        // pick the lowest (largest y) matching word
        let best = null;
        for (const d of state.drops) {
          if (!d.text.startsWith(prefix)) continue;
          if (!best || d.y > best.y) best = d;
        }
        return best ? best.id : null;
      }

      function commitIfComplete() {
        const typed = input.value.trim();
        if (!typed) return false;

        const t = state.drops.find(d => d.id === state.targetId);
        if (!t) return false;

        if (typed === t.text) {
          // score
          state.hits++;
          state.combo++;
          const mult = 1 + Math.min(0.75, state.combo * 0.05);
          const base = 10 * t.text.length;
          state.score += Math.round(base * mult);

          // remove drop
          removeDrop(t);
          state.drops = state.drops.filter(d => d.id !== t.id);

          // feedback
          beep(740, 0.06, 0.06, "triangle");
          if (state.combo % 5 === 0) beep(980, 0.07, 0.05, "sine");

          // clear input and retarget
          input.value = "";
          state.lastInput = "";
          setTarget(null);

          updateHud();
          return true;
        }
        return false;
      }

      function countAccuracyDelta(newVal) {
        // only count newly added characters (not backspace, not paste delete)
        const prev = state.lastInput;
        if (newVal.length <= prev.length) return;

        const added = newVal.slice(prev.length);
        const prefix = newVal.trim(); // target matching ignores leading/trailing
        const t = state.drops.find(d => d.id === state.targetId);

        for (let i = 0; i < added.length; i++) {
          const ch = added[i];
          if (ch === "\n" || ch === "\r") continue;

          // treat spaces as "commit attempts", not accuracy characters
          if (ch === " ") continue;

          state.typedChars++;

          if (t) {
            const pos = (newVal.trim().length - 1) - i; // rough, but stable enough
            // better: compare based on trimmed position
            const trimmedPrevLen = prev.trim().length;
            const trimmedNewLen = newVal.trim().length;
            const addedTrimCount = trimmedNewLen - trimmedPrevLen;
            const idxInWord = trimmedPrevLen + Math.max(0, i - (added.length - addedTrimCount));

            const expected = t.text[idxInWord];
            if (expected && ch === expected) state.correctChars++;
          }
        }
      }

      function updateHud() {
        scoreEl.textContent = String(state.score);
        levelEl.textContent = String(state.level);
        accuracyEl.textContent = `${accuracyPct()}%`;
        missesEl.textContent = `${state.misses} / ${state.maxMisses}`;

        const mult = 1 + Math.min(0.75, state.combo * 0.05);
        comboEl.textContent = `x${mult.toFixed(2)}`;
        updateTargetLabel();
      }

      function setOverlay(show, title = "Typing Rain", text = "") {
        overlay.style.display = show ? "grid" : "none";
        overlayTitle.textContent = title;
        overlayText.textContent = text || overlayText.textContent;
      }

      function startGame() {
        if (state.gameOver) resetGame();

        state.running = true;
        state.paused = false;

        setOverlay(false);
        btnStart.textContent = "Running";
        btnPause.textContent = "Pause";

        input.focus({ preventScroll:true });
      }

      function pauseGame(toggle = true) {
        if (!state.running) return;
        if (toggle) state.paused = !state.paused;
        btnPause.textContent = state.paused ? "Resume" : "Pause";
        if (!state.paused) input.focus({ preventScroll:true });
      }

      function endGame() {
        state.gameOver = true;
        state.running = false;
        state.paused = false;

        const acc = accuracyPct();
        setOverlay(true, "Game Over", `Score: ${state.score}. Accuracy: ${acc}%. Hits: ${state.hits}. Misses: ${state.misses}.`);

        btnStart.textContent = "Start";
        btnPause.textContent = "Pause";
        beep(220, 0.10, 0.07, "sawtooth");
        beep(180, 0.12, 0.05, "sine");
      }

      function resetGame() {
        // clear drops
        for (const d of state.drops) removeDrop(d);
        state.drops = [];

        // reset state
        state.running = false;
        state.paused = false;
        state.gameOver = false;

        state.score = 0;
        state.level = 1;

        state.hits = 0;
        state.misses = 0;

        state.typedChars = 0;
        state.correctChars = 0;

        state.combo = 0;

        state.elapsed = 0;
        state.spawnTimer = 0;

        state.targetId = null;
        state.lastInput = "";
        input.value = "";

        updateHud();
        setOverlay(true, "Typing Rain", "Survive the storm: type the words before they reach the bottom. Difficulty ramps up over time.");
        btnStart.textContent = "Start";
        btnPause.textContent = "Pause";
      }

      function missDrop(d) {
        state.misses++;
        state.combo = 0;

        d.el.classList.add("miss");
        beep(140, 0.05, 0.05, "square");

        removeDrop(d);
        state.drops = state.drops.filter(x => x.id !== d.id);

        if (state.targetId === d.id) {
          state.targetId = null;
          targetLabel.textContent = "None";
        }

        updateHud();
        if (state.misses >= state.maxMisses) endGame();
      }

      function update(dt) {
        if (!state.running || state.paused || state.gameOver) return;

        state.elapsed += dt;
        const newLevel = levelFromTime(state.elapsed);
        if (newLevel !== state.level) {
          state.level = newLevel;
          updateHud();
        }

        // spawn words
        state.spawnTimer += dt * 1000;
        const iv = spawnIntervalMs(state.level);

        while (state.spawnTimer >= iv) {
          state.spawnTimer -= iv;
          makeDrop(pickWord(state.level));
        }

        // move drops
        for (const d of state.drops) {
          d.y += d.speed * dt;
          positionDrop(d);

          // if bottom reached
          if (d.y >= state.bottomY) {
            missDrop(d);
            break; // list mutated
          }
        }

        // keep target rendering in sync
        renderTypedOnTarget();
      }

      // Input handling
      input.addEventListener("input", () => {
        if (!state.running || state.paused || state.gameOver) return;

        const raw = input.value;
        const trimmed = raw.trim();

        // update target based on prefix
        const best = findBestTarget(trimmed);
        setTarget(best);

        // accuracy accounting (lightweight, per added char)
        countAccuracyDelta(raw);
        state.lastInput = raw;

        // auto-commit if exact match
        if (commitIfComplete()) return;

        updateHud();
      });

      input.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          e.preventDefault();
          if (state.running) pauseGame(true);
          return;
        }

        if (!state.running || state.paused || state.gameOver) return;

        // Space / Enter attempts commit and clears if not matching
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();

          const did = commitIfComplete();
          if (!did) {
            // if they typed nonsense, keep it short: clear and lose combo
            if (input.value.trim().length > 0) {
              state.combo = 0;
              beep(110, 0.05, 0.04, "square");
            }
            input.value = "";
            state.lastInput = "";
            setTarget(null);
            updateHud();
          }
        }
      });

      // Buttons
      btnStart.addEventListener("click", () => startGame());
      btnPause.addEventListener("click", () => pauseGame(true));
      btnReset.addEventListener("click", () => resetGame());

      btnPlayOverlay.addEventListener("click", () => startGame());
      btnFocusInput.addEventListener("click", () => input.focus({ preventScroll:true }));

      // Global keyboard: Enter starts if overlay is up
      window.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && overlay.style.display !== "none") {
          startGame();
        }
      }, { passive:false });

      // Main loop
      let last = performance.now();
      function loop(now) {
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;
        update(dt);
        requestAnimationFrame(loop);
      }

      // init
      resize();
      resetGame();
      requestAnimationFrame(loop);

      // small UX: click field focuses input
      app.addEventListener("pointerdown", (e) => {
        if (e.target === input) return;
        input.focus({ preventScroll:true });
      });
    })();
  </script>
</body>
</html>
